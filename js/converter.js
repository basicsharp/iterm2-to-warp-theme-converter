/**
 * iTerm2 to Warp Theme Converter - Core Logic
 * Handles parsing iTerm2 themes and converting them to Warp format
 */

/**
 * Converts RGB components (0.0-1.0) to a hex color string.
 * @param {number} r - Red component (0.0 to 1.0)
 * @param {number} g - Green component (0.0 to 1.0)
 * @param {number} b - Blue component (0.0 to 1.0)
 * @returns {string} The hex color string (e.g., "#RRGGBB").
 */
const toHex = (r, g, b) => {
    const to255 = (v) => Math.round(parseFloat(v) * 255);
    const toHexPart = (v) => to255(v).toString(16).padStart(2, '0');
    return `#${toHexPart(r)}${toHexPart(g)}${toHexPart(b)}`;
};

/**
 * Parses a <dict> element from the iTerm XML to extract its color.
 * @param {Element} dictElement - The <dict> XML element.
 * @returns {string|null} The hex color string or null if parsing fails.
 */
const getColorFromDict = (dictElement) => {
    if (!dictElement || dictElement.tagName !== 'dict') return null;

    const color = {};
    const children = dictElement.children;

    // Parse key-value pairs in the dict
    for (let i = 0; i < children.length - 1; i++) {
        const keyElement = children[i];
        const valueElement = children[i + 1];

        if (keyElement.tagName === 'key' && 
            (valueElement.tagName === 'real' || valueElement.tagName === 'string')) {
            
            const key = keyElement.textContent;
            const value = valueElement.textContent;

            if (key === 'Red Component' && valueElement.tagName === 'real') {
                color.r = value;
            } else if (key === 'Green Component' && valueElement.tagName === 'real') {
                color.g = value;
            } else if (key === 'Blue Component' && valueElement.tagName === 'real') {
                color.b = value;
            }
        }
    }

    if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
        return toHex(color.r, color.g, color.b);
    }
    return null;
};

/**
 * Determines if a color is light or dark to set the 'details' property.
 * @param {string} hex - The hex color string.
 * @returns {'darker' | 'lighter'}
 */
const getDetailsValue = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    // Using the luminance formula
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? 'darker' : 'lighter';
};

/**
 * Formats the JavaScript theme object into a YAML string.
 * @param {object} theme - The theme object.
 * @returns {string} The formatted YAML string.
 */
const toYaml = (theme) => {
    return `
# Generated by iTerm2 to Warp Theme Converter - https://basicsharp.github.io/iterm2-to-warp-theme-converter/
accent: '${theme.accent}'
background: '${theme.background}'
foreground: '${theme.foreground}'
cursor: '${theme.cursor}'
cursor_text: '${theme.cursor_text}'
selection_background: '${theme.accent}'
selection_text: '${theme.selection_text}'
details: '${theme.details}'

terminal_colors:
  normal:
    black:   '${theme.terminal_colors.normal.black}'
    red:     '${theme.terminal_colors.normal.red}'
    green:   '${theme.terminal_colors.normal.green}'
    yellow:  '${theme.terminal_colors.normal.yellow}'
    blue:    '${theme.terminal_colors.normal.blue}'
    magenta: '${theme.terminal_colors.normal.magenta}'
    cyan:    '${theme.terminal_colors.normal.cyan}'
    white:   '${theme.terminal_colors.normal.white}'
  bright:
    black:   '${theme.terminal_colors.bright.black}'
    red:     '${theme.terminal_colors.bright.red}'
    green:   '${theme.terminal_colors.bright.green}'
    yellow:  '${theme.terminal_colors.bright.yellow}'
    blue:    '${theme.terminal_colors.bright.blue}'
    magenta: '${theme.terminal_colors.bright.magenta}'
    cyan:    '${theme.terminal_colors.bright.cyan}'
    white:   '${theme.terminal_colors.bright.white}'
`.trim();
};

/**
 * Parses flattened iTerm2 color format (non-XML).
 * @param {string} content - The flattened content.
 * @returns {object} The parsed theme object.
 */
const parseFlattenedFormat = (content) => {
    const warpTheme = {
        terminal_colors: { normal: {}, bright: {} }
    };

    const iTermToWarpMap = {
        'Ansi 0 Color': 'normal.black',
        'Ansi 1 Color': 'normal.red',
        'Ansi 2 Color': 'normal.green',
        'Ansi 3 Color': 'normal.yellow',
        'Ansi 4 Color': 'normal.blue',
        'Ansi 5 Color': 'normal.magenta',
        'Ansi 6 Color': 'normal.cyan',
        'Ansi 7 Color': 'normal.white',
        'Ansi 8 Color': 'bright.black',
        'Ansi 9 Color': 'bright.red',
        'Ansi 10 Color': 'bright.green',
        'Ansi 11 Color': 'bright.yellow',
        'Ansi 12 Color': 'bright.blue',
        'Ansi 13 Color': 'bright.magenta',
        'Ansi 14 Color': 'bright.cyan',
        'Ansi 15 Color': 'bright.white',
        'Background Color': 'background',
        'Foreground Color': 'foreground',
        'Cursor Color': 'cursor',
        'Cursor Text Color': 'cursor_text',
        'Selection Color': 'accent',
        'Selected Text Color': 'selection_text',
    };

    // Improved regex to handle the specific flattened format from iTerm2 export
    // This handles content like "Ansi 0 Color Alpha Component 1 Blue Component 0.123 Color Space Calibrated Green Component 0.456 Red Component 0.789"
    const colorRegex = /((?:Ansi \d+|Background|Foreground|Cursor|Cursor Text|Selection|Selected Text|Badge|Bold|Link|Cursor Guide) Color)[\s\S]*?(?=(?:Ansi \d+|Background|Foreground|Cursor|Cursor Text|Selection|Selected Text|Badge|Bold|Link|Cursor Guide) Color|$)/g;
    
    const colorMatches = content.match(colorRegex);

    if (!colorMatches) {
        throw new Error("No color definitions found in flattened format.");
    }

    for (const match of colorMatches) {
        // Extract color name from the beginning
        const colorNameMatch = match.match(/^((?:Ansi \d+|Background|Foreground|Cursor|Cursor Text|Selection|Selected Text|Badge|Bold|Link|Cursor Guide) Color)/);
        if (!colorNameMatch) continue;
        
        const colorName = colorNameMatch[1];
        
        // Extract RGB components using more flexible regex
        const redMatch = match.match(/Red Component\s+([\d.]+)/);
        const greenMatch = match.match(/Green Component\s+([\d.]+)/);
        const blueMatch = match.match(/Blue Component\s+([\d.]+)/);

        if (redMatch && greenMatch && blueMatch) {
            const r = parseFloat(redMatch[1]);
            const g = parseFloat(greenMatch[1]);
            const b = parseFloat(blueMatch[1]);

            const warpName = iTermToWarpMap[colorName];
            if (warpName && !isNaN(r) && !isNaN(g) && !isNaN(b)) {
                const hexColor = toHex(r, g, b);
                if (warpName.includes('.')) {
                    const [group, name] = warpName.split('.');
                    warpTheme.terminal_colors[group][name] = hexColor;
                } else {
                    warpTheme[warpName] = hexColor;
                }
            }
        }
    }

    return warpTheme;
};

/**
 * Main conversion function that handles both XML and flattened formats.
 * @param {string} itermContent - The iTerm2 theme content.
 * @returns {string} The converted Warp YAML theme.
 */
const convertITermToWarp = (itermContent) => {
    if (!itermContent.trim()) {
        throw new Error("Input is empty. Please paste your theme content.");
    }

    let warpTheme;

    // Check if it's XML format or flattened format
    if (itermContent.includes('<?xml') || itermContent.includes('<plist')) {
        // Handle XML format
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(itermContent, "application/xml");

        if (xmlDoc.getElementsByTagName("parsererror").length) {
            throw new Error("Invalid XML. Please check the pasted content.");
        }

        const keys = xmlDoc.getElementsByTagName('key');

        if (keys.length === 0) {
            throw new Error("No color definitions found. Make sure you've pasted a valid .itermcolors file.");
        }

        warpTheme = {
            terminal_colors: { normal: {}, bright: {} }
        };

        const iTermToWarpMap = {
            'Ansi 0 Color': 'normal.black',
            'Ansi 1 Color': 'normal.red',
            'Ansi 2 Color': 'normal.green',
            'Ansi 3 Color': 'normal.yellow',
            'Ansi 4 Color': 'normal.blue',
            'Ansi 5 Color': 'normal.magenta',
            'Ansi 6 Color': 'normal.cyan',
            'Ansi 7 Color': 'normal.white',
            'Ansi 8 Color': 'bright.black',
            'Ansi 9 Color': 'bright.red',
            'Ansi 10 Color': 'bright.green',
            'Ansi 11 Color': 'bright.yellow',
            'Ansi 12 Color': 'bright.blue',
            'Ansi 13 Color': 'bright.magenta',
            'Ansi 14 Color': 'bright.cyan',
            'Ansi 15 Color': 'bright.white',
            'Background Color': 'background',
            'Foreground Color': 'foreground',
            'Cursor Color': 'cursor',
            'Cursor Text Color': 'cursor_text',
            'Selection Color': 'accent',
            'Selected Text Color': 'selection_text',
        };

        for (const key of keys) {
            try {
                if (!key || !key.textContent) continue;

                const keyName = key.textContent.trim();
                const warpName = iTermToWarpMap[keyName];

                if (warpName) {
                    const dict = key.nextElementSibling;
                    const color = getColorFromDict(dict);
                    if (color) {
                        if (warpName.includes('.')) {
                            const [group, name] = warpName.split('.');
                            warpTheme.terminal_colors[group][name] = color;
                        } else {
                            warpTheme[warpName] = color;
                        }
                    }
                }
            } catch (err) {
                // Skip invalid entries and continue processing
                console.warn('Skipping invalid color entry:', err);
                continue;
            }
        }
    } else {
        // Handle flattened format
        warpTheme = parseFlattenedFormat(itermContent);
    }

    // Check if we found any colors
    const hasAnyColors = warpTheme.background || warpTheme.foreground ||
        Object.keys(warpTheme.terminal_colors.normal).length > 0 ||
        Object.keys(warpTheme.terminal_colors.bright).length > 0;

    if (!hasAnyColors) {
        throw new Error("No valid colors found in the input. Please ensure you've pasted a complete .itermcolors file.");
    }

    // Set defaults for any missing essential colors
    warpTheme.background = warpTheme.background || '#000000';
    warpTheme.foreground = warpTheme.foreground || '#FFFFFF';
    warpTheme.accent = warpTheme.accent || warpTheme.terminal_colors.normal.blue || '#528BFF';
    warpTheme.cursor = warpTheme.cursor || warpTheme.foreground;
    warpTheme.cursor_text = warpTheme.cursor_text || warpTheme.background;
    warpTheme.selection_text = warpTheme.selection_text || warpTheme.background;

    // Determine 'details' based on background luminance
    warpTheme.details = getDetailsValue(warpTheme.background);

    return toYaml(warpTheme);
}; 